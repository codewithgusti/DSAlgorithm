Singly linked lists

A linked list (also called a singly linked list) contains a number of nodes in which each node contains data and a pointer that links to the next node. 
The link of the last node in the list is None, which indicates the end of the list. 

Refer to the following linked list in Figure 4.6, in which a sequence of integers is stored


Next, we discuss how to create a singly linked list, and how to traverse it.

Creating and traversing

In order to implement the singly linked list, we can use the node class that we created in the previous section. 
For example, we create three nodes, n1, n2, and n3, that store three strings:

n1 = Node('eggs')
n2 = Node('ham') 
n3 = Node('spam')

Next, we link the nodes sequentially to form the linked list. 
For example, in the following code, 

node n1 is pointing to node n2, 
node n2 is pointing to node n3, 
and node n3 is the last node, and is pointing to None:

n1.next = n2
n2.next = n3

Traversal of the linked lists means visiting all the nodes of the list, from the starting node to the last node. 
The process of traversing the singly linked list begins with the first node, 
displaying the data of the current node, following the pointers, 
and finally stopping when we reach the last node.

To implement the traversal of the linked list, 
we start by setting the current variable to the first item (starting node) in the list, 
and then we traverse the complete list through a loop, 
traversing each node as shown in the following code:

current = n1 
while current:
     print(current.data)
     current = current.next

In the loop, we print out the current element after which we set current to point to the next element in the list. 
We keep doing this until we reach the end of the list. 

There are, however, several problems with this simplistic list implementation:

   - It requires too much manual work by the programmer
   -Too much of the inner workings of the list is exposed to the programmer

So, let us discuss a better and more efficient way of traversing the linked list.

Improving list creation and traversal


As you will notice in the earlier example of the list traversal, 
we are exposing the node class to the client/user. 
However, the client node should not interact with the node object. 
We need to use node.data to get the contents of the node, 
and node.next to get the next node. 
We can access the data by creating a method that returns a generator, 
which can be done using the yield keyword in Python. 

The updated code snippet for list traversal is as follows:

def iter(self):
    current = self.head 
    while current:
        val = current.data 
        current = current.next 
        yield val
Here, the yield keyword is used to return from a function while saving the states of its local variables to enable the function to resume from where it left off. 
Whenever the function is called again, the execution starts from the last yield statement. 
Any function that contains a yield keyword is termed a generator.

Now, list traversal is much simpler.
We can completely ignore the fact that there is anything called a node outside of the list:

 for word in words.iter():
    print(word)
Notice that since the iter() method yields the data member of the node, our client code doesn’t need to worry about that at all.

A singly linked list can be created using a simple class to hold the list. 
We start with a constructor that holds a reference to the very first node in the list (that is head in the following code). 
Since this list is initially empty, we will start by setting this reference to None:

class SinglyLinkedList:
    def __init__ (self):
        self.head = None
In the preceding code, we start with an empty list that points to None. 
Now, new data elements can be appended/added to this list.

Appending items

The first operation that we need to perform is to append items to the list. 
This operation is also called an insertion operation. 
Here we get a chance to hide the Node class away. 
The user of the list class should never have to interact with Node objects.

Appending items to the end of a list

Let’s have a look at the Python code for creating a linked list where we append new elements to the list using the append() method, as shown here:

The first shot at an append() method may look like this:

class SinglyLinkedList:
    def __init__ (self):  
        self.head = None  
        self.size = 0
def append(self, data):
    # Encapsulate the data in a Node 
    node = Node(data)
    if self.head is None:
        self.head = node
    else:
        current = self.head
        while current.next:
            current = current.next
        current.next = node
Here, in this code, we encapsulate data in a node so that it has the next pointer attribute. 
From here, we check if there are any existing nodes in the list (that is, whether self.head points to a Node). 
If there is None, this means that initially, the list is empty and the new node will be the first node. 
So, we make the new node the first node of the list; otherwise, 
we find the insertion point by traversing the list to the last node and updating the next pointer of the last node to the new node. 

This working is depicted in Figure 4.7.

Figure 4.7: Inserting a node at the end of the list in a singly linked list

Consider the following example code to append three nodes:
words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')

List traversal will work as we discussed before. 
You will get the first element of the list from the list itself, 
and then traverse the list through the next pointer:

current = words.head
while current:
   print(current.data)
   current = current.next

Still, this implementation is not very efficient,and there is a drawback with the append method. 
In this, we have to traverse the entire list to find the insertion point. 
This may not be a problem when there are just a few items in the list, 
but it will be very inefficient when the list is long, 
as it will have to traverse the whole list to add an item every time. 

Let us discuss a better implementation of the append method.

For this, the idea is that we not only have a reference to the first node in the list but also have one more variable in the node that references the last node of the list. 
That way, we can quickly append a new node at the end of the list. 
The worst-case running time of the append operation can be reduced from O(n) to O(1) using this method.
We must ensure that the previous last node points to the new node that is to be appended to the list.

class SinglyLinkedList:
    def __init__ (self):
        self.tail = None
        self.head = None
        self.size = 0
    def append(self, data):
        node = Node(data)
        if self.tail:
            self.tail.next = node
            self.tail = node
        else:
            self.head = node 
            self.tail = node
Take note of the convention being used. 
The point at which we append new nodes is through self.tail. 
The self.head variable points to the first node in the list.

In Figure 4.8, step 1 shows the addition of the new node at the end, and step 2 shows when the list is empty. 
In that case, head is made the new node, with tail pointing to that node.

Furthermore, the following code snippet shows the workings of the code:

words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
 
current = words.head
while current:
    print(current.data)
    current = current.next

Appending items at intermediate positions

To append or insert an element in an existing linked list at a given position, 
firstly, we have to traverse the list to reach the desired position where we want to insert an element. 
An element can be inserted in between two successive nodes using two pointers (prev and current).


When we want to insert a node in between two existing nodes, all we have to do is update two links. 
The previous node points to the new node, and the new node should point to the successor of the previous node.

class SinglyLinkedList:
    def __init__ (self):
        self.tail = None
        self.head = None
        self.size = 0
    def append_at_a_location(self, data, index): 
        current = self.head 
        prev = self.head 
        node = Node(data)
        count = 1
        while current:
            if count == 1:        
                node.next = current
                self.head = node
                print(count)
                return
            elif index == index:
                node.next = current 
                prev.next = node
                return
            count += 1
            prev = current
            current = current.next
        if count < index:
            print("The list has less number of elements")


In the preceding code, we start from the first node and move the current pointer to reach the index position where we want to add a new element, and then we update the node pointers accordingly. 
In the if condition, firstly, we check whether the index position is 1. 
In that case, we have to update the nodes as we are adding the new node at the start of the list. 
Therefore, we have to make the new node a head node. Next, in the else part, we check whether we have reached the required index position by comparing the value of count and index. 
If both values are equal, we add a new node in between nodes indicated by prev and current and update the pointers accordingly. 
Finally, we print an appropriate message if the required index position is greater than the length of the linked list.

The following code snippet uses the append method to add a “new” data element at an index position of 2 in the existing linked list:

words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
current = words.head
while current:
    print(current.data)
    current = current.next
words.append_at_a_location('new', 2)
current = words.head
while current:
    print(current.data)
    current = current.next

It is important to note that the condition where we may want to insert a new element can change depending upon the requirement, 
so let’s say we want to insert a new element just before an element that has the same data value. 

In that case, the code to append_at_a_position will be as follows:

def append_at_a_location(self, data): 
    current = self.head 
    prev = self.head
    node = Node(data)
    while current:
        if current.data == data:
            node.next = current 
            prev.next = node
        prev = current
        current = current.next

We can now use the preceding code to insert a new node at an intermediate position:

words.append_at_a_location('ham')
current = words.head
while current:
    print(current.data)
    current = current.next




Querying a list
A linked list is not suitable for query operations like finding the nth item in the list or counting the number of items with a specific property.
A linked list is not designed for query operations like finding the nth item in the list or getting the sum of all items in the list.

Once the list is created, we may require some quick information about the linked list, such as the size of the list, and occasionally to establish whether a given data item is present in the list.

Searching an element in a list


We may also need to check whether a list contains a given item. 
This can be implemented using the iter() method, which we have already seen in the previous section while traversing the linked list. 

Using that, we write the search method as follows:

def search(self, data):
    for node in self.iter():
        if data == node:
            return True
    return False

In the above code, each pass of the loop compares the data to be searched with each data item in the list one by one. If a match is found, True is returned, otherwise False is returned.

If we run the following code for searching a given data item:
print(words.search('sspam'))
print(words.search('spam'))


Getting the size of the list

It is important to get the size of the list by counting the number of nodes. 
One way to do it is by traversing the entire list and increasing the counter as we go along:

def size(self):
    count = 0
    current = self.head
    while current:
        count += 1
        current = current.next
    return count
The above code is very similar to what we did while traversing the linked list. Similarly, in this code, we traverse the nodes of the list one by one and increase the count variable. However, list traversal is potentially an expensive operation that we should avoid wherever we can.

So instead, we can opt for another method in which we can add a size member to the SinglyLinkedList class, initializing it to 0 in the constructor, as shown in the following code snippet:

class SinglyLinkedList:
    def __init__(self):
        self.head = data
        self.size = 0

Because we are now only reading the size attribute of the node object, and not using a loop to count the number of nodes in the list, we reduce the worst-case running time from O(n) to O(1).

Deleting items


Another common operation on a linked list is to delete nodes. 
There are three possibilities that we may encounter in order to delete a node from the singly linked list.

Deleting the node at the beginning of the singly linked list

Deleting a node from the beginning is quite easy. 
It involves updating the head pointer to the second node in the list. 

This can be done in two steps:

A temporary pointer (current pointer) is created that points to the first node (head node), 
as shown in Figure 4.10.


Next, the current node pointer is moved to the next node and assigned to the head node. 
Now, the second node becomes the head node that is pointed to by the head pointer, 
as shown in Figure 4.11.



Figure 4.11: After deleting the first node, the head pointer now points to the new starting element

This can be implemented using the following Python code. 
In this code, initially, 
three data elements are added as we have done previously, 
and then the first node of the list is deleted:

def delete_first_node (self):
       current = self.head  
        if self.head is None:
              print("No data element to delete")
        elif current == self.head:
              self.head = current.next  

In the above code, we initially check if there is no item to delete from the list, and we print the appropriate message. 
Next, if there is some data item in the list, we assign the head pointer to the temporary pointer current as per step 1,
and then the head pointer is now pointing to the next node, 
assuming that we already have a linked list of three data items – “eggs”, “ham”, and “spam”:

words.delete_first_node()
current = words.head
while current:
    print(current.data)
    current = current.next

Deleting the node at the end in the singly linked list
To delete the last node from the list, we have to first traverse the list to reach the last node. 
At that time, we also need an extra pointer that points to just one node before the last node, 
so that after deleting the last node, the second last node can be marked as the last node. 
It can be implemented in the following three steps:

Firstly, we have two pointers, in other words, a current pointer that will point to the last node, 
and a prev pointer that will point to the node previous to the last node (second last node). 
Initially, we will have three pointers (current, prev, and head) pointing to the first node, 

as shown in Figure 4.12.

To reach the last node, we move the current and prev pointers in such a way that the current pointer 
should point to the last node and the prev pointer should point to the second last node. 
So, we stop when the current pointer reaches the last node. 

This is shown in Figure 4.13.

Finally, we mark the prev pointer to point to the second last node, 
which is rendered as the last node of the list by pointing this node to None, 

as shown in Figure 4.14.

    def delete_last_node (self):  
        current = self.head  
        prev = self.head  
        while current: 
            if current.next is None: 
                prev.next = current.next  
                self.size -= 1 
            prev = current 
            current = current.next

In the preceding code, firstly, the current and prev pointers are assigned the head pointer as per step 1. Then, in the while loop, we check whether we reached the end of the list using the current.next is None condition. Once we reach the end of the list, we make the second last node, which is indicated by the prev pointer, the last node. We also decrement the size of the list. If we do not reach the end of the list, we increment the prev and current pointers in the while loop in the last two lines of code. Next, let us discuss how to delete any intermediate node in a singly linked list.

Deleting any intermediate node in a singly linked list
We first have to decide how to select a node for deletion. Identifying the intermediate node to be deleted can be determined by the index number or by the data the node contains. Let us understand this concept by deleting a node depending on the data it contains.

To delete any intermediary node, we need two pointers similar to the case when we learned to delete the last node; in other words, the current pointer and the prev pointer. Once we reach the node that is to be deleted, the desired node can be deleted by making the previous node point to the next node of the node that is to be deleted. The process is provided in the following steps:

Figure 4.15 shows when an intermediate node is deleted from the given linked list. In this, we can see that the initial pointers point to the first node.

Figure 4.15: Illustration of the deletion of an intermediate node from the linked list

Once the node is identified, the prev pointer is updated to delete the node, as shown in Figure 4.16. The node to be deleted is shown along with the link to those to be updated in Figure 4.16.

Figure 4.16: Traversing to reach the intermediate node that is to be deleted in the linked list

Finally, the list after deleting the node is shown in Figure 4.17

Figure 4.17: Deletion of an intermediate node from the linked list

Let’s say we want to delete a data element that has the given value. For this given condition, we can first search the node to be deleted and then delete the node as per the steps discussed.

Here is what the implementation of the delete() method may look like:

def delete(self, data):
    current = self.head 
    prev = self.head 
    while current:
          if current.data == data:
              if current == self.head:
                  self.head = current.next 
              else:
                  prev.next = current.next 
              self.size -= 1
              return
          prev = current
          current = current.next

Assuming that we already have a linked list of three items – “eggs”, “ham”, and “spam”, the following code is for executing the delete operation, that is, deleting a data element with the value “ham” from the given linked list:

words.delete("ham")
current = words.head
while current:
    print(current.data)
    current = current.next

The worst-case time complexity of the delete operation is O(n) since we have to traverse the list to reach the desired position and, in the worst-case scenario, we may have to traverse all the n nodes in the list.

Clearing a list
We may need to clear a list quickly, and there is a very simple way to do this. We can clear a list by simply clearing the pointer head and tail by setting them to None:

def clear(self):
    # clear the entire list.
    self.tail = None
    self.head = None
In the above code, we can clear the list by assigning None to the tail and head pointers.