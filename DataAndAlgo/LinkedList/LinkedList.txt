
Linked Lists

Python’s list implementation is quite powerful and can encompass several different use cases. 
We have discussed the built-in data structures of lists in Python in Chapter 1, Python Data Types and Structures. 
Most of the time, Python’s built-in implementation of a list data structure is used to store data using a linked list. 
In this chapter, we will understand how linked lists work along with their internals.

A linked list is a data structure where the data elements are stored in a linear order. 
Linked lists provide efficient storage of data in linear order through pointer structures. 
Pointers are used to store the memory address of data items. 
They store the data and location, and the location stores the position of the next data item in the memory.

The focus of this chapter will be the following:

- Arrays
- Introducing linked lists
- Singly linked lists
- Doubly linked lists
- Circular lists
- Practical applications of linked lists


Arrays

An array is a collection of data items of the same type, whereas a linked list is a collection of the same data type stored sequentially and connected through pointers.
In the case of lists, the data elements are stored in different memory locations, whereas the array elements are stored in contiguous memory locations.

An array stores the data of the same data type and each data element in the array is stored in contiguous memory locations. 
Storing multiple data values of the same type makes it easier and faster to compute the position of any element in the array using offset and base address. 
The term base address refers to the address of memory location where the first element is stored, and offset refers to an integer indicating the displacement between the first element and a given element.

Figure 4.1 demonstrates an array holding a sequence of seven integer values that are stored sequentially in contiguous memory locations. 
The first element (data value 3) is stored at index 0, the second element at index position 1, and so on.


Figure 4.1: Representation of a one-dimensional array

To store, traverse, and access array elements is very fast as compared to lists since elements can be accessed randomly using their index positions, whereas in the case of a linked list, the elements are accessed sequentially. 
Therefore, if the data to be stored in the array is large and the system has low memory, the array data structure will not be a good choice to store the data because it is difficult to allot a large block of memory locations. 
The array data structure has further limitations in that it has a static size that has to be declared at the time of creation.

In addition, the insertion and deletion operations in array data structures are slow as compared to linked lists. 
This is because it is difficult to insert an element in an array at a given location since all data elements after that desired position must be shifted and then new elements inserted in between. 
Thus, array data structures are suitable when we want to do a lot of accessing of elements and fewer insertion and deletion operations, whereas linked lists are suitable in applications where the size of the list is not fixed, and a lot of insertion and deletion operations will be required.

Introducing linked lists

The linked list is an important and popular data structure with the following properties:

 1.  
     The data elements are stored in memory in different locations that are connected through pointers. 
     A pointer is an object that can store the memory address of a variable, and each data element points to the next data element and so on until the last element, which points to None.

 2. 
    The length of the list can increase or decrease during the execution of the program.



Contrary to arrays, linked lists store data items sequentially in different locations in memory, wherein each data item is stored separately and linked to other data items using pointers. 
Each of these data items is called a node. More specifically, a node stores the actual data and a pointer. 

In Figure 4.2, nodes A and B store the data independently, and node A is connected to node B.


Figure 4.2: A linked list with two nodes

Moreover, the nodes can have links to other nodes based differently on how we want to store the data, 
and on which basis we will learn various kinds of data structures, 
such as singular linked lists, doubly linked lists, circular link lists, and trees.

Nodes and pointers

A node is a key component of several data structures such as linked lists. 
A node is a container of data, together with one or more links to other nodes where a link is a pointer.

To begin with, let us consider an example of creating a linked list of two nodes that contains data (for example, strings). 
For this, we first declare the variable that stores the data along with pointers that point to the next variable. 
Consider the example in the following Figure 4.3, in which there are two nodes. 
The first node has a pointer to the string (eggs), and another node pointing to the ham string.

Furthermore, the first node that points to the eggs string has a link to another node. 
Pointers are used to store the address of a variable, and since the string is not actually stored in the node, 
rather, the address of the string is stored in the node.


Figure 4.3: A sample linked list of two nodes

Furthermore, we can also add a new third node to this existing linked list that stores spam as a data value, 
while a second node points to the third node, as shown in Figure 4.4. 
Hence, Figure 4.3 demonstrates the structure of three nodes having data strings, 
in other words, eggs, ham, and spam, which are stored sequentially in a linked list.


Figure 4.4: A sample linked list of three nodes

So, we have created three nodes—one containing eggs, one ham, and another spam. 
The eggs node points to the ham node, which in turn points to the spam node. 
But what does the spam node point to? Since this is the last element in the list, we need to make sure its next member has a value that makes this clear. 
If we make the last element point to nothing, then we make this fact clear. 
In Python, we will use the special value None to denote nothing. 
Consider Figure 4.5. Node B is the last element in the list, and thus it is pointing to None.


Let us first learn about the implementation of the node, as shown in the following code snippet:

class Node:
    def __init__ (self, data=None):
        self.data = data 
        self.next = None
Here, the next pointer is initialized to None, meaning that unless we change the value of next, 
the node is going to be an endpoint, meaning that initially, 
any node that is attached to the list will be independent.


You can also add any other data items to the node class if required. 
If your node is going to contain customer data, then create a Customer class and place all the data there.

There are three kinds of list—a singly linked list, a doubly linked list, and a circular linked list. 

First of all, let’s discuss singly linked lists.

We need to learn the following operations in order to use any linked lists in real-time applications.


